<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>记assign引发的血案 | Log'K'</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">记assign引发的血案</h1><a id="logo" href="/.">Log'K'</a><p class="description">Learn more.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">记assign引发的血案</h1><div class="post-meta">May 18, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="就那么一个Bug"><a href="#就那么一个Bug" class="headerlink" title="就那么一个Bug"></a>就那么一个Bug</h2><p>话说一大清早就让 <a href="https://try.crashlytics.com/" target="_blank" rel="external">Crashlytics</a>的邮件给吵醒了，随手点开一股熟悉的Bug扑面而来；</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/2015-05-18-ji-assginyin-fa-de-xie-an/pic1.png" alt="1.1"></p>
<p>看到这里的时候不经疑问了，用到烂了的 <code>NetManager</code> ，是不可能出现这种问题的，难道是 <code>delegate</code> 未滞空？！可当自己看到 <code>dealloc</code> 里面的代码时候就分分钟打了脸。<br>就在百思不得骑姐的时候，我看到了<code>.h</code>里面 delegate 的属性声明</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span>&lt;NetManagerDelegate&gt; targetDelegate;</div></pre></td></tr></table></figure>
<p>等等，项目好像已经换ARC了有一段时间了，这个 <code>assign</code> 难道是遗漏了？然而在查阅了了一下这类的问题的时候，眼眶一下就湿润了…</p>
<h2 id="先补补属性-property-里面常用的特质"><a href="#先补补属性-property-里面常用的特质" class="headerlink" title="先补补属性(property)里面常用的特质"></a>先补补属性(property)里面常用的特质</h2><p>伴随着iOS5一起出现的 <code>property</code> 幸福了一大批（po猪就是其中之一）厌恶了手写 <code>setter</code> 和 <code>getter</code> 方法的开发者，当然 property 的优点也不止步于这点，强大的特质支持可以更有效的提升开发效率，其中常用的属性特质有：</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>assign 常用于“常量类型”（ float , int…）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">CGFloat</span> aFloat;    </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) <span class="built_in">NSInteger</span> num;</div></pre></td></tr></table></figure>
<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><p>weak 是伴随着ARC出现的特质，某些上面是和 assign 相同的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="keyword">id</span> obj;        <span class="comment">//不会保留新值，不会释放旧值</span></div></pre></td></tr></table></figure>
<p>区别就在于用weak标记的属性所指的对象释放的时候，该属性值也会滞空（nil）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ABC * abc = [[ABC alloc]init];</div><div class="line">_obj = abc;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"_obj_before = %@"</span>,_obj);</div><div class="line">abc = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"_obj_after = %@"</span>,_obj);        <span class="comment">//打印出来的是nil</span></div><div class="line">而<span class="keyword">assign</span>标记的属性所赋的旧值未能释放。</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"_obj_after = %@"</span>,_obj);    <span class="comment">//将weak换成assign，依旧能log出旧值来</span></div></pre></td></tr></table></figure>
<h3 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h3><p>unsafe_unretained 则是在 weak 还没有出现，也就是iOS5以前用于标记那些“对象类型”的特质，一方面该特质等同于 assign。同时 ARC 情况下用 assign 标记的属性对象编译器会默认转换成 unsafe_unretained</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>) ABC * obj;        </div><div class="line"><span class="comment">//@property (unsafe_unretained) ABC * obj;    //等同于</span></div><div class="line">然而当目标对象释放的时候，属性值不会自动清空，这点和<span class="keyword">weak</span>还是有区别的。</div></pre></td></tr></table></figure>
<h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>为了避免多线程同时访问一个属性所导致的读写问题。苹果提出了“原子性”这一特质。默认情况下所有的属性都是 atomic。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="keyword">id</span> obj1;   </div><div class="line"><span class="comment">//@property (atomic,strong) id obj1;    //等同于</span></div></pre></td></tr></table></figure>
<p>然而atomic问题在于当一个线程重复操作一个属性的同时，另一个线程也对该属性更改的时候，也会出现读出错误数据的时候。所以线程的安全还是需要一个严谨的逻辑作为支撑，加之更深层的锁，而不是单单靠一个特质来限制的。</p>
<h3 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h3><p>iOS开发久了都会习惯了一个写属性的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span> obj2;</div></pre></td></tr></table></figure>
<p>使用 nonatomic 去标记一个属性，其实就是“关闭”默认的 atomic 。因为在iOS开发当中默认的 atomic 是需要额外消耗性能,另方面就是 atomic 在多线程这块的不完美，导致开发者更愿意自己去处理多线程读写，而放弃 atomic 。</p>
<h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p> retain 是配合苹果的引用计数管理内存所使用到的特质。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">retain</span>) <span class="keyword">id</span> obj;</div></pre></td></tr></table></figure>
<p>当被标记 retain 的属性会对其所指向的值的 <code>retainCount</code> 进行retain（也就是retainCount＋1）。同样的，当你不再需要该属性的时候需要手动 <code>release</code> 去释放（retainCount－1）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ABC * abc = [[ABC alloc]init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[abc retainCount]);        <span class="comment">//retainCount = 1</span></div><div class="line"><span class="keyword">self</span>.obj = abc;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[abc retainCount]);        <span class="comment">//retainCount = 2</span></div><div class="line">[<span class="keyword">self</span>.obj release];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,[abc retainCount]);        <span class="comment">//retainCount = 1</span></div></pre></td></tr></table></figure>
<h3 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h3><p> strong 是伴随着ARC同时出现的特质，但 strong 不会影响所赋值的 retainCount ，当然 ARC 的思想早已脱去了 MRC 下的 retainCount 概念。按我个人理解来看， strong 沿袭的是 ARC 内存管理机制，而引用计数( MRC 时代)则生出了 retain 。当然你在 ARC 项目里面使用 retain ，等效于 strong 。<br>这2条是摘自 Clang 文档里面的解释。</p>
<blockquote>
<p>retain implies __strong ownership.</p>
<p>strong implies __strong ownership.</p>
</blockquote>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p> copy 特质常被用于 NSString , NSArray 这类满足 NSCopying 协议的类属性，目的在于保护该属性所指向的值的完整性。摘自 stackover 上面的这段代码很好的解释了copy的作用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableString</span> *someName = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"Chris"</span>];</div><div class="line">Person *p = [[[Person alloc] init] autorelease];</div><div class="line">p.name = someName;</div><div class="line">[someName setString:<span class="string">@"Debajit"</span>];   <span class="comment">//someName的改变不会影响到name所指向的值，因为已经copy了</span></div></pre></td></tr></table></figure>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>这个特质顾名思意你对于这个标记的属性只具备 getter 功能，无法对其指向的内容进行更改，换种说法也就是无法执行setter方法。然而面对有些需求：“如何对一个属性向外只读，对内可读可写？”可以尝试以下方法。<br>头文件（.h）中声明该属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  ViewController.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readonly</span>) <span class="built_in">NSString</span> * test;  <span class="comment">//在这里声明</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>再在类扩展里面重写这个属性:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  ViewController.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readwrite</span>) <span class="built_in">NSString</span> * test;   <span class="comment">//在这里重写即可</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="readwrite"><a href="#readwrite" class="headerlink" title="readwrite"></a>readwrite</h3><p> readwrite 创建属性的时候默认特质,让开发者具备 getter 和 setter 权限。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> * test;</div><div class="line"><span class="comment">// @property (nonatomic,strong,readwrite) NSString * test;  //等同于</span></div></pre></td></tr></table></figure>
<h2 id="还是之前那个Bug"><a href="#还是之前那个Bug" class="headerlink" title="还是之前那个Bug"></a>还是之前那个Bug</h2><p>之前那个问题就出在assign上面。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">id</span>&lt;NetManagerDelegate&gt; targetDelegate;</div></pre></td></tr></table></figure>
<p>虽然在相应的VC中的 <code>dealloc</code> 方法里 <code>targetDelegate＝nil</code> ，但是实际上这个属性后面的旧值并未释放，这个时候VC释放之后，这个属性所指的就成了野指针了，MRC下100%引起Crash，而ARC情况下则略有不同（好吧ARC的实现原理po猪又偷懒了，之后再把ARC的坑填上好了…）导致这个crash并非100%重现，也就出现了刚开始那个email了～<br>自己写的代码含泪也得fix完…<br>那就这样吧…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://stackoverflow.com/questions/8927727/objective-c-arc-strong-vs-retain-and-weak-vs-assign" target="_blank" rel="external">stackoverflow上面一个比较全面关于特质的问题和解答</a></p>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">Clang关于ARC的文档</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2015/05/18/记assign引发的血案/" data-id="cis7djbfj000vm1u5rid8zd4x" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2015/06/16/写在总结之前/" class="pre">写在总结之前</a><a href="/2015/04/26/是时候gank一波iOS内存管理了/" class="next">是时候gank一波iOS内存管理了</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂感/">杂感</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/在这个特殊的日子，我们来聊聊-KVO-吧/">在这个特殊的日子，我们来聊聊 KVO 吧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/Apple-pay-体验报告/">Apple pay 体验报告</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/2015-终总结和-2016-的-flag/">2015 终总结和 2016 的 flag</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/22/Scrapy-爬虫学习中不可或缺的利器/">Scrapy 爬虫学习中不可或缺的利器</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/28/Python-爬虫学习（三）/">Python 爬虫学习（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/18/Python-爬虫学习（二）/">Python 爬虫学习（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/16/Python-爬虫学习（一）/">Python 爬虫学习（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/06/深入了解-iOS-中的-Block/">深入了解 iOS 中的 Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/18/CodeSign和App的爱恨情仇/">CodeSign和App的爱恨情仇</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/06/iOS补漏和拾遗，从BAT的面试题出发（二）/">iOS补漏和拾遗，从BAT的面试题出发（二）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/KepenJ" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Log'K'.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>