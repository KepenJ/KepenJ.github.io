<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>EffectiveOC学习整理(一) | Log'K'</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">EffectiveOC学习整理(一)</h1><a id="logo" href="/.">Log'K'</a><p class="description">Learn more.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">EffectiveOC学习整理(一)</h1><div class="post-meta">Jun 17, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="关于OC的起源"><a href="#关于OC的起源" class="headerlink" title="关于OC的起源"></a>关于OC的起源</h2><p>这一条介绍了OC语言的设计思路，同时举出一些例子用于介绍OC语言的特性，以及和C语言之间的关联。</p>
<p>对于已经不再是新手的iOSer看来，看上去这一条并无什么卵用。但是从语言设计的根本层面来讲这一条提出的:<a href="https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E_%E8%BB%9F%E9%AB%94" target="_blank" rel="external">消息结构</a>和<a href="http://www.cnblogs.com/codemood/p/3203537.html" target="_blank" rel="external">函数调用</a>的区别值得深思。</p>
<h2 id="头文件里面尽量少的导入其他头文件"><a href="#头文件里面尽量少的导入其他头文件" class="headerlink" title="头文件里面尽量少的导入其他头文件"></a>头文件里面尽量少的导入其他头文件</h2><p>说到这节，个人认为有几个点需要注意:</p>
<ol>
<li>两个声明: <code>@class</code> 和 <code>#import</code></li>
<li>程序的编译状态</li>
<li>头文件的设计和封装</li>
</ol>
<h2 id="class和-import"><a href="#class和-import" class="headerlink" title="@class和#import"></a>@class和#import</h2><p>首先 <code>#import</code> 和 <code>@class</code> 都是用在导入头文件时候所用到的声明，是给计算机看的语句，作用在程序编译的时候。举个简单的例子.</p>
<p>用@class向ViewController里面导入一个Test类文件:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ViewController.h</span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Test</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span> ｛</span></div><div class="line">    Test * _test;</div><div class="line">｝</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>然后再在ViewController.m再导入这个类的的头文件 <code>Test.h</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ViewController.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Test.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div></pre></td></tr></table></figure>
<p>若果你这样去写的话，就好比只让编译器知道“哦，这里有个 <code>Test</code> 类的指针啊～”，从而编译器不再去关心 <code>Test</code> 里面到底有什么参数和方法。如果你也整需要如此，那么这样是做好的选择，因为它可以有效的缩短编译时间。</p>
<p>但是如果你需要创建同时访问 <code>Test</code> 里面的东西的时候，你需要让编译器知道 <code>Test</code> 内部的详细信息，你也就要用到 <code>#import</code> 这个声明了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ViewController.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Test.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>#import</code>所标识的头文件，编译器就会老老实实的查看且纪录。这点和 C 语言中的 #include 是一样的，与其说一样，倒不如说 #import 是 Apple 针对 #include “<code>重复导入头文件而无法编译</code>”这个问题的一个解决方案。</p>
<h2 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h2><p>其次就在于之前一直提到的程序编译状态，这个活是由编译器进行处理的。因为种种原因 Apple 未能使用强大 GCC ，转而自行研发了基于 LLVM 的 Clang 编译器。</p>
<p> Object-C 是 C 语言的一种集合或者说是超类。所以从 C 语言的编译角度出发，包含了一下四步：</p>
<ol>
<li>预处理(Preprocessing)</li>
<li>编译(Compilation)</li>
<li>汇编(Assembly)</li>
<li>链接(Linking)</li>
</ol>
<p>用C最初的helloworld举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(“Hello, world.\n”);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应的在编译阶段，程序会经历一下几个阶段：</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/EffectiveOC%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86\(%E4%B8%80\" alt="1.1">/gcc_compilation_stages.jpg)</p>
<p>具体细节的就不在这里说明了，大家可以去原博文<a href="http://smilejay.com/2012/01/c_compilation_stages/" target="_blank" rel="external">C程序编译过程浅析</a>细看。</p>
<h2 id="头文件的设计和封装"><a href="#头文件的设计和封装" class="headerlink" title="头文件的设计和封装"></a>头文件的设计和封装</h2><p>“一千个coder就有一千个哈姆雷特”，如何去封装，去设计自己的头文件，刨根揭底都是为了效地减少程序编译所带来的消耗。其中有几点是我现在在开发中常用到的：</p>
<ul>
<li>一对一的Delegate写到头文件(.h)中，并在需要的类的class-continuation(.m)中引入头文件。</li>
<li>无用或不需要暴露的参数、API不要写在头文件中(.h)。</li>
</ul>
<p>当然优化程序编译的方法不止这些，在之后的小节中还会提到另一种可以有效缩短程序编译时间的方法。（还想有点开始偏离这张所讲的了…）</p>
<h2 id="多用字面量语法"><a href="#多用字面量语法" class="headerlink" title="多用字面量语法"></a>多用字面量语法</h2><p>很多没有用过OC的小伙伴，第一眼看到OC语法的时候，两个字“头大”。OC繁杂的语言一直遭人诟病（po主其实没什么感觉…），于是乎Clang提出了字面量（literal syntax）语法。</p>
<p><code>NSNumber</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> * num = @<span class="number">1</span>;</div><div class="line"><span class="comment">//NSNumber * num = [NSNumber numberWithInt:1];</span></div></pre></td></tr></table></figure>
<p><code>NSString</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> * test = <span class="string">@"test"</span>;</div><div class="line"><span class="comment">//NSString * test = [NSString stringWithString:@"test"];</span></div></pre></td></tr></table></figure>
<p><code>NSArray</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//set</span></div><div class="line"><span class="built_in">NSString</span> * test = <span class="string">@"test"</span>;</div><div class="line"><span class="built_in">NSArray</span> * testArray = @[test];</div><div class="line"><span class="comment">//NSArray * testArray = [NSArray arrayWithObjects:test, nil];</span></div><div class="line"><span class="comment">//get</span></div><div class="line"><span class="built_in">NSString</span> * test1 = testArray[<span class="number">0</span>];</div><div class="line"><span class="comment">//NSString * test1 = [testArray objectAtIndex:0];</span></div></pre></td></tr></table></figure>
<p><code>NSDictionary</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//set</span></div><div class="line"><span class="built_in">NSString</span> * test = <span class="string">@"test"</span>;</div><div class="line"><span class="built_in">NSDictionary</span> * testDic = @&#123;<span class="string">@"key"</span>: test&#125;;</div><div class="line"><span class="comment">//NSDictionary * testDic = [NSDictionary dictionaryWithObjectsAndKeys:@"key",test, nil];</span></div><div class="line"><span class="comment">//get</span></div><div class="line"><span class="built_in">NSString</span> * test1 = testDic[<span class="string">@"key"</span>];</div><div class="line"><span class="comment">//NSString * test1 = [testDic objectForKey:@"key"];</span></div></pre></td></tr></table></figure>
<p>而现今Apple提供给开发者的字面量语法只限定于创建不可变的对象，如需要创建可变的，则需要复制一份。</p>
<p><code>NSMutableArray</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//set</span></div><div class="line"><span class="built_in">NSString</span> * test = <span class="string">@"test"</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> * testMArray = [@[test] mutableCopy];</div><div class="line"><span class="comment">//NSMutableArray * testMArray = [NSMutableArray arrayWithObjects:test, nil];</span></div><div class="line"><span class="comment">//replace</span></div><div class="line">testMArray[<span class="number">0</span>] = <span class="string">@"hello"</span>;</div><div class="line"><span class="comment">//[testMArray replaceObjectAtIndex:0 withObject:@"hello"];</span></div></pre></td></tr></table></figure>
<p><code>NSMutableDictionary</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//set</span></div><div class="line"><span class="built_in">NSString</span> * test = <span class="string">@"test"</span>;</div><div class="line"><span class="built_in">NSMutableDictionary</span> * testMDic = [@&#123;<span class="string">@"key"</span>:test&#125; mutableCopy];</div><div class="line"><span class="comment">//NSMutableDictionary * testMDic = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"key",test, nil];</span></div><div class="line"><span class="comment">//add</span></div><div class="line">testMDic[<span class="string">@"key2"</span>] = <span class="string">@"hello"</span>;</div><div class="line"><span class="comment">//[testMDic setObject:@"hello" forKey:@"key2"];</span></div></pre></td></tr></table></figure>
<p>同样的，字面量语法有着很大的局限性，因为它只提供了部分 <code>Foundation</code> 框架的类对象的方法，如果是自定义的类，字面量语法就无能为力了。</p>
<p>即便字面量语法可发挥的地方比较局限，也无法掩盖他的优点。下边这段代码很好的诠释：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1 = <span class="string">@"1"</span>;</div><div class="line"><span class="keyword">id</span> obj2 = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">id</span> obj3 = <span class="string">@"3"</span>;</div><div class="line"><span class="built_in">NSArray</span> * testArray1 = @[obj1,obj2,obj3];  <span class="comment">//crash</span></div><div class="line"><span class="built_in">NSArray</span> * testArray2 = [<span class="built_in">NSArray</span> arrayWithObjects:obj1,obj2,obj3, <span class="literal">nil</span>]; <span class="comment">//只包含obj1</span></div></pre></td></tr></table></figure>
<p>同样去创建一个包含3个对象的NSArray，如果当obj2为nil的时候，结果却不尽相同。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> * testArray1 = @[obj1,obj2,obj3];</div></pre></td></tr></table></figure>
<p>这句的结果会致使程序Crash</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/EffectiveOC%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86(%E4%B8%80" alt="1.2">/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-05%20%E4%B8%8B%E5%8D%884.40.30.png)</p>
<p>然而下面这句代码则致使 <code>testArray2</code> 里面只包含了 <code>obj1</code> 一个对象，因为 <code>arrayWithObjects:</code> 这句话是以 <code>nil</code> 作为结束符为判断，判断是否结束了创建：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> * testArray2 = [<span class="built_in">NSArray</span> arrayWithObjects:obj1,obj2,obj3, <span class="literal">nil</span>]; <span class="comment">//只包含obj1</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,testArray2);</div></pre></td></tr></table></figure>
<p>Log出的结果:</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/EffectiveOC%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86(%E4%B8%80" alt="1.3">/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-07-05%20%E4%B8%8B%E5%8D%884.46.33.png)</p>
<p>从这两个句话的返回结果来看，在开发途中让应用抛出异常，要好比最后上线之后再发现问题要好得多。更多针对字面量语句的可以查询Clang关于字面量的介绍。</p>
<h2 id="少使用-＃define-，多用类型常量"><a href="#少使用-＃define-，多用类型常量" class="headerlink" title="少使用 ＃define ，多用类型常量"></a>少使用 <code>＃define</code> ，多用类型常量</h2><p>说到#define这个宏定义，包括po猪在内有很长一段时间，都会因为省事、方便等诸多原因，使用#define来声明很多全局或者是局部的常量，或固定的语句、方法。</p>
<p>其实这条在自身项目当中，目的在于减少预处理常量类型时候使用的#define，我们可以将类似于底下这句代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kTest (@<span class="meta-string">"hello"</span>)</span></div></pre></td></tr></table></figure>
<p>使用常量类型来定义，来替换上面这个实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Test1.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> test;</div><div class="line"><span class="comment">//Test1.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> test = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> test = <span class="string">@"hello"</span>;</div></pre></td></tr></table></figure>
<p>这样做的好处在于：</p>
<ol>
<li>#define定义出来的变量不包含类型信息，编译器也只是在编译期间去查找并替换宏定义出来的参数.</li>
<li>#define因为是简单的替换，所以当有人重新定义了常量值的时候，编译器是不会产生警告的。</li>
<li>其中extern或者static＋const的组合使用，可以完全取代用#define来定义一些类似于外部调用或者内部调用所定义的常量，其中const修饰符可以有效地避免一些参数的修改。<br>（关于extern,static,const的介绍可以看如下<a href="http://faculty.cs.niu.edu/~freedman/241/241notes/241var2.htm" target="_blank" rel="external">参考</a>）。</li>
</ol>
<h2 id="枚举的妙用"><a href="#枚举的妙用" class="headerlink" title="枚举的妙用"></a>枚举的妙用</h2><p>因为OC算是C语言的扩展，自然沿袭了C语言乃至之前的很多优良特性，“枚举”就是其中之一。而我们作为从C、OC再到iOS开发者，枚举这个数据类型已经耳熟能详，设置项目中早已用到了，其中在表示“状态”、“选项”当中使用的最频繁。（或者说枚举感觉就是为这些情况而创建出来的）。</p>
<p>从这一节中，有两点值得学习。（最起码po猪从中受益良多 - -||）</p>
<ol>
<li>“选项”中枚举的编写方式。</li>
<li>枚举的向下兼容。<br>在这里具体的枚举就不一一介绍了，<a href="https://en.wikipedia.org/wiki/Enumerated_type" target="_blank" rel="external">Wiki</a>中甚至其它各种文章和 Blog 里面介绍的都很详细。但是如果开发者在定义“选项”的时候，枚举和位运算的结合将带来非常方便的体验。</li>
</ol>
<p>就用Apple定义的屏幕翻转状态，可以很好的放映出来 enum 在”选项”方面的优势</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIInterfaceOrientationMask</span>) &#123;</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskPortrait</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortrait</span>),</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> = (<span class="number">1</span> &lt;&lt; 	<span class="built_in">UIInterfaceOrientationLandscapeLeft</span>),</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> = (<span class="number">1</span> &lt;&lt; 	<span class="built_in">UIInterfaceOrientationLandscapeRight</span>),</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span> = (<span class="number">1</span> &lt;&lt; 	<span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span>),</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskLandscape</span> = (<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskAll</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> | <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</div><div class="line">	<span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中“<a href="http://c.biancheng.net/cpp/html/101.html" target="_blank" rel="external">按位或操作符</a>”可以组合多个选项，所以我们才可以在 <code>supportedInterfaceOrientationsForWindow</code> 方法中进行多项选择；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="built_in">UIWindow</span> *)window &#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscape</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>细心的开发者应该注意到了 <code>NS_OPTIONS</code> 和 <code>NS_ENUM</code> 这两个宏定义，然而这两个宏定义在声明枚举的时候是有区别的。其中在 <code>NSObjCRuntime.h</code> 中这两个宏定义的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (__cplusplus)  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_OPTIONS(_type, _name) _type _name; enum : _type  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_ENUM(_type, _name) _type _name; enum  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_OPTIONS(_type, _name) _type _name; enum  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>其中从 <code>NS_ENUM</code> 定义来看， <code>_type</code> 用于存储的新类型的类型， <code>_name</code> 则跟以前一样用于定义枚举的名称。<br>相比 C 语言之前最早的枚举定义来看，指明底层 _type 意味着可以向前声明枚举变量了。因为编译器在编译的时候就知道了枚举底层数据的大小，也就可以提前给他分配好可用的内存空间了。甚至有提示编辑器在进行 switch 判断时检查类型匹配的功能。</p>
<p>如果说咱们常创建的从0开始的枚举是 NS_ENUM 标注的，那么 NS_OPTIONS 则是使用于位运算声明所使用的。然而 C++ 和非 C++ 情况下的实现是不相同的，因为枚举依旧是由底层类型(也就是之前提到的 _type )所构成，同时枚举之经常需要用按位或运算来组合， C++ 中不允许“隐式转换”进行赋值，而一定需要进行“显示转换”的方式，于是乎 Apple 就给出了 NS_OPTIONS 的宏定义用来处理这个”转换”的问题。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://stackoverflow.com/questions/322597/class-vs-import" target="_blank" rel="external">Stackover上面一个关于@class和#import的问题</a></p>
<p><a href="http://smilejay.com/2012/01/c_compilation_stages/" target="_blank" rel="external">C程序编译过程浅析</a></p>
<p><a href="https://linuxtoy.org/archives/llvm-and-clang.html" target="_blank" rel="external">LLVM与Clang的介绍</a></p>
<p><a href="http://llvm.org/docs/" target="_blank" rel="external">Dragon Book</a></p>
<p><a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html" target="_blank" rel="external">Clang关于字面量的介绍</a></p>
<p><a href="http://faculty.cs.niu.edu/~freedman/241/241notes/241var2.htm" target="_blank" rel="external">extern,static,const的参考</a></p>
<p><a href="https://en.wikipedia.org/wiki/Enumerated_type" target="_blank" rel="external">Wiki关于Enum的介绍</a></p>
<p><a href="http://c.biancheng.net/cpp/html/101.html" target="_blank" rel="external">按位或操作符</a></p>
<p><a href="http://nshipster.cn/ns_enum-ns_options/" target="_blank" rel="external">NS_ENUM &amp; NS_OPTIONS</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2015/06/17/EffectiveOC学习整理-一/" data-id="cis7j69jy0009rpu5tmolhdr8" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2015/07/08/关于自定义一个滤镜效果/" class="pre">关于自定义一个滤镜效果</a><a href="/2015/06/16/写在总结之前/" class="next">写在总结之前</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂感/">杂感</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/21/C-学习笔记（二）：类和对象/">C++学习笔记（二）：类和对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/C-学习笔记（一）：C-基本和新增特性/">C++学习笔记（一）：C++基本和新增特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/21/iAP-的一波玩弄/">iAP 的一波玩弄</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/20/A-new-beginning/">A new beginning.</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/28/关于近期面试有感/">关于近期面试有感</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/记一次失败的OS-X-重装/">记一次失败的OS X 重装</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/从-Octopress-换-Hexo-了/">从 Octopress 换 Hexo 了</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/Apple-pay-体验报告/">Apple pay 体验报告</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/2015-终总结和-2016-的-flag/">2015 终总结和 2016 的 flag</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/22/Scrapy-爬虫学习中不可或缺的利器/">Scrapy 爬虫学习中不可或缺的利器</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/KepenJ" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Log'K'.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>