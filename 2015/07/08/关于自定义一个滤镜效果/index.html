<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>关于自定义一个滤镜效果 | Log'K'</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于自定义一个滤镜效果</h1><a id="logo" href="/.">Log'K'</a><p class="description">Learn more.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于自定义一个滤镜效果</h1><div class="post-meta">Jul 8, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间受友人之托，帮忙去实现一个滤镜效果。吭哧吭哧了半个月总算是有所交代了，写这篇博文也用于分享自己这半个月来，如何从0到1去实现这个滤镜需求的心得体会。</p>
<h2 id="关于需求"><a href="#关于需求" class="headerlink" title="关于需求"></a>关于需求</h2><p>需求是几张PS的截图（因为大小的关系这里不展示原图，之后会整合到项目里面用于参考），用来演示这个滤镜实现的过程和步骤。在这里很庆幸自己之前用过一段时间的PS，于是乎自己先通过PS按照所给的步骤截图实现了一遍，用于了解整个滤镜的业务流程。</p>
<p>首先是原图:</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C/1.png" alt="1.1"></p>
<p>滤镜效果步骤大体分为了4大步:</p>
<ol>
<li>红色的不饱和度调整为-80和不透明度调整为26%。</li>
<li>照片柔光效果。</li>
<li>选取需要过滤的一个色值(R:255G:159B:45)，并设置不透明度为6%。</li>
<li>进行色值排除。</li>
</ol>
<p>经过滤镜处理后的效果图:</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C/6.png" alt="1.2"></p>
<h2 id="收集和学习"><a href="#收集和学习" class="headerlink" title="收集和学习"></a>收集和学习</h2><p>作为一个开发者，同时也是滤镜小白，拿到如此需求的第一反应就是Google。“iOS滤镜制作”、“自定义滤镜”、“Shader入门基础”…经过一连串的搜索和了解于是乎收获了以下几方面的知识点:</p>
<ul>
<li>GPUImage的使用和了解</li>
<li>CoreImage、OpenGL、OpenGLES各自的优缺点</li>
<li>图形学知识点和图形算法</li>
<li>Shader基本入门语法</li>
<li>PhotoShop里面的滤镜math</li>
</ul>
<h3 id="GPUImage一个好用的第三方滤镜框架"><a href="#GPUImage一个好用的第三方滤镜框架" class="headerlink" title="GPUImage一个好用的第三方滤镜框架"></a>GPUImage一个好用的第三方滤镜框架</h3><p><code>GPUImage</code> 是基于 <code>OpenGLES</code> 框架封装而成的，里面包含了丰富、成型的滤镜效果，po猪在学习、了解滤镜制作的时候也是大量参照了GPUImage里面现有的滤镜实现源码进行的。所有的滤镜均使用GLSL进行编写，所以说如果开发者需要自定义滤镜效果的话Shader语言则是必不可少的。更多关于GPUImage的介绍，可以参考所在的 <a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">Github源码及介绍</a>。</p>
<h3 id="CoreImage、OpenGL和OpenGLES"><a href="#CoreImage、OpenGL和OpenGLES" class="headerlink" title="CoreImage、OpenGL和OpenGLES"></a>CoreImage、OpenGL和OpenGLES</h3><p><code>OpenGLES</code> 则是是针对手机、PDA和游戏主机等嵌入式设备，基于OpenGL三维图形API的子集框架。之所以选择OpenGLES，很大的一点在于它的实现是通过GPU进行，从而不再占有CPU。</p>
<p><code>OpenGL</code> 这个节不再介绍了，这里不再介绍了（基本市场上的很图像处理软件都是基于它实现的）。市场上面的红皮书和 <a href="https://zh.wikipedia.org/wiki/OpenGL" target="_blank" rel="external">wiki</a> 里面说的都非常详细。</p>
<p><code>CoreImage</code> 是苹果提供给开发者的一个基于图片处理的框架，该框架底层也是基于GLSL的子集进行图像处理。框架的好处在于：</p>
<ol>
<li>由 Apple 提供给开发者的，处理时会更好的支持与Apple设备的底层硬件。</li>
<li>封装好的 API 通俗易懂，降低了学习成本。</li>
<li>兼容 OpenGL 协同开发。</li>
</ol>
<p>相对应的缺点也很明显:</p>
<ol>
<li>过度封装的 API 会致使很多效果实现受限，说白了就是不太容易 DIY 自己想要的滤镜。</li>
<li>创建上下文会占用一定的 CPU 和内存。</li>
</ol>
<p>所以在这次写这个滤镜的时候，我没有考虑使用 CoreImage 进行编写，而是使用 OpenGLES 。更多的关于 CoreImage 的介绍可以参考 Objc 中国里面的<a href="http://objccn.io/issue-21-6/" target="_blank" rel="external">Core Image 介绍</a>。</p>
<h3 id="一点点图形学、图形算法和GLSL的入门"><a href="#一点点图形学、图形算法和GLSL的入门" class="headerlink" title="一点点图形学、图形算法和GLSL的入门"></a>一点点图形学、图形算法和GLSL的入门</h3><p>如果开发者想要理解滤镜的实现原理，这就需要开发者具备一定的图形学知识，同时了解部分图形算法，这样才可以理解它的为什么这么去写，为什么这个算法就能得出我所想要的效果。之后会在本位结尾处分享出一些相关知识点的链接。</p>
<p>关于 <a href="https://www.opengl.org/documentation/glsl/" target="_blank" rel="external">GLSL(OpenGL Shading Language)</a> 的详细介绍，网上有太多现成的轮子，这里就不铺开聊了。我们只需要知之后所要用到的滤镜，都是通过 GLSL 实现的，我会在之后详解自己所写的GLSL代码。相关资料同样也会在之后会给出来。</p>
<h2 id="Just-Do-It"><a href="#Just-Do-It" class="headerlink" title="Just Do It"></a>Just Do It</h2><p>相关 Demo 我已经放到 <a href="https://github.com/KepenJ/CustomFilterDemo" target="_blank" rel="external">Github</a> 上面了，不想看文章的可以直接下载去研究。</p>
<h2 id="关于项目Demo"><a href="#关于项目Demo" class="headerlink" title="关于项目Demo"></a>关于项目Demo</h2><p>下图这张图就是Demo的工程目录，其中排去其中VC和View不看（这些也是友人要求的…），我这里将上面提到的4个步骤进行了分步处理。GPUImage也因为最初只导入了project一些杂七杂八的路径问题，导致真机无法测试（一切都ok却卡到了这，太尴尬了…）,所以直接干成了静态库。</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C/4.png" alt="2.1"></p>
<p>下面这张是我们的核心滤镜</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C/2.png" alt="2.2"></p>
<p>其中.fsh文件是OpenGLES着色器(Shader)文件，使用的就是GLSL语言编写。当然还有另一种是.vsh文件。针对这两个文件的详细介绍，可以参考这篇博文<a href="http://www.cnblogs.com/slysky/p/3949718.html" target="_blank" rel="external">.fsh和.vsh介绍</a>。</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C/3.png" alt="2.3"></p>
<h2 id="忍不住再赞美GPUImage"><a href="#忍不住再赞美GPUImage" class="headerlink" title="忍不住再赞美GPUImage"></a>忍不住再赞美GPUImage</h2><p>Demo中使用的则是OC文件，CustomFilter是继承于GPUImage中GPUImageFilter所编写的类文件。GPUImage很好的封装了底层OpenGLES的相关的接口，使开发者无需深入到怎样设置OpenGL/OpenGLES使用着色器渲染，只需要关注传入的参数，和滤镜的实现效果即可。</p>
<p>CustomFilter.h和.m里面细节的实现代码就不在这里说明了。这块主要讲讲滤镜实现的代码，毕竟使用的是GLSL，有必要解释和说明一下。</p>
<h2 id="滤镜的详解"><a href="#滤镜的详解" class="headerlink" title="滤镜的详解"></a>滤镜的详解</h2><p>下面是 <code>CustomFilter.fsh</code> 里面的源码，也就是咱们所用到的滤镜：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">varying highp vec2 textureCoordinate;</div><div class="line">uniform sampler2D inputImageTexture;</div><div class="line"><span class="keyword">const</span> mediump vec3 luminanceWeighting = vec3(<span class="number">0.2125</span>, <span class="number">0.7154</span>, <span class="number">0.0721</span>);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</div><div class="line">    highp vec4 newTureColor = texture2D(inputImageTexture, textureCoordinate);</div><div class="line">    highp <span class="keyword">float</span> luminance = dot(textureColor.rgb, luminanceWeighting);</div><div class="line">    highp vec3 greyScaleColor = vec3(luminance,textureColor.g,textureColor.b);</div><div class="line">    newTureColor = vec4(mix(greyScaleColor, textureColor.rgb, <span class="number">0.2</span>), <span class="number">0.26</span>);</div><div class="line">    newTureColor.rgb = (<span class="number">2.0</span> * textureColor.rgb * newTureColor.rgb + textureColor.rgb * textureColor.rgb * (<span class="number">1.0</span> - <span class="number">2.0</span> * newTureColor.rgb));</div><div class="line">    newTureColor = vec4(mix(textureColor.rgb, newTureColor.rgb, newTureColor.a * alpha), textureColor.a);</div><div class="line">    highp vec4 exclusionRGB;</div><div class="line">    exclusionRGB = vec4(<span class="number">1.0</span>, <span class="number">0.6234</span>, <span class="number">0.1764</span>, (<span class="number">1.0</span><span class="number">-0.06</span>));</div><div class="line">    highp vec4 newTureColor_last;</div><div class="line">    newTureColor_last = (newTureColor + exclusionRGB - <span class="number">2.0</span> * newTureColor * exclusionRGB);</div><div class="line">    newTureColor = vec4(mix(textureColor.rgb, newTureColor_last.rgb, newTureColor_last.a * <span class="number">1.0</span>), <span class="number">1.0</span>);</div><div class="line">    gl_FragColor = newTureColor;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="拆分讲解"><a href="#拆分讲解" class="headerlink" title="拆分讲解"></a>拆分讲解</h2><p><code>varying highp vec2 textureCoordinate;</code><br>首先我们需要创建一个高质量的二维顶点坐标信息信息参数，用于着色器内部交流。so，varying是用于定义顶点着色器和片段着色器内部交流所使用，highp则表示变量的高精度，vec2表示包含两个浮点数的向量例如(a,b)这种。</p>
<p><code>uniform sampler2D inputImageTexture;</code><br>接下来我们需要一个对接外部素材的参数。uniform的作用就是用来定义对接外部的参数，sampler2D表明这个参数对接的是一个2D素材。</p>
<p><code>const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);</code><br>const这里我就不说明了，这句话的含义表明，定义了一个不可更改的包含3个符点型的向量，并赋值(0.2125, 0.7154, 0.0721)。这里我插一句，这个参数为什么这么定义，出自<a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00CE17178" target="_blank" rel="external">《图形着色器:理论与实践》</a>至于为什么这么写，说实在的没有研究过图形学的我也不清楚…想明白为什么的同学可以去看看这本书，同时可以参考一下<a href="http://gamedev.stackexchange.com/questions/21352/what-is-the-point-of-this-hard-coded-vector-when-calculating-luminance-in-glow-b" target="_blank" rel="external">老外问的这个问题</a>。</p>
<p>接下来就进入我们的main函数了:</p>
<p><code>highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</code><br>接下来我们通过导入inputImageTexture结合二维顶点坐标信息textureCoordinate创建一个高精度的2D纹理textureColor，在这里textureColor是一个四维参数，这四个符点型分别是R,G,B,Alpha。</p>
<p><code>highp float luminance = dot(textureColor.rgb, luminanceWeighting);</code><br>dot()函数就是我们线性代数中的点乘计算，点乘计算以包含纹理颜色信息的 vec4为参数，舍弃vec4的最后一个不需要的元素，将它和相对应的亮度权重相乘。然后取出所有的三个值把它们加在一起，计算出这个像素综合的亮度值。</p>
<p><code>highp vec3 greyScaleColor = vec3(luminance,textureColor.g,textureColor.b);</code><br>之后我们我们创建一个vec3的灰度值，用的就是之前求出来的luminance，当然这个值只影响R也就是我们只改变红色的饱和度。</p>
<p><code>newTureColor = vec4(mix(greyScaleColor, textureColor.rgb, 0.2), 0.26);</code><br>mix()函数将两个值(例如颜色值)混合为一个变量。我们将greyScaleColor和textureColor.rgb的两个vec3向量用mix()函数线性插值。还记得之前第一步骤么，“红色的不饱和度调整为-80和不透明度调整为26%”。但是这个-80是PS里面给出的数值，于是换算到咱们函数当中的取值就是现在的0.2，当然Alpha则还是0.26。</p>
<p><code>newTureColor.rgb = (2.0 * textureColor.rgb * newTureColor.rgb + textureColor.rgb * textureColor.rgb * (1.0 - 2.0 * newTureColor.rgb));</code><br>这段函数算法取自GPUImage中柔光滤镜，之后查了一下好像PS里面的柔光滤镜的Math用的就是这个。</p>
<p><code>#define BlendSoftLightf(base, blend)     ((blend &lt; 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))</code><br>上面这个就是传说中PhotoShop中“柔光”效果的math。</p>
<p><code>exclusionRGB = vec4(1.0, 0.6234, 0.1764, (1.0-0.06));</code><br>然后我们创建一个排除用的色值(R:255G:159B:45)，并设置不透明度为6%，这块我这里做了(1.0-0.06)因为我这块针对alpha取值做了很多次尝试，发现从效果上来看反相选取出来的值正是我想要的（偷懒没去研究原理…）。</p>
<p><code>newTureColor_last = (newTureColor + exclusionRGB - 2.0 * newTureColor * exclusionRGB);</code><br>最后一步就是我们的”排除”步骤了。上面这个算法来自PhotoShop中的排除算法：</p>
<p><code>#define BlendExclusion(base, blend)     (base + blend - 2.0 * base * blend)</code><br>GPUImage框架中的融合算法和这个还有一定的区别，导致exclusionRGB设置alpha的直接失效，换用现在这个算法发现就正常了….</p>
<p><code>gl_FragColor = newTureColor;</code><br>最后我们将处理好的素材内容，通过着色器进行渲染。</p>
<p>最后的效果</p>
<p><img src="https://raw.githubusercontent.com/KepenJ/BlogImages/master/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E9%95%9C/7.png" alt="2.4"></p>
<p>最后实现的效果图和用PS做出来的滤镜果然还是有差距的，毕竟一个只花了半个月做出来的滤镜不足于PK一个专业且成熟的商业软件… :)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这次DIY滤镜的需求解决总结出几点：</p>
<p>图形学和图像算法的重要性，只有明白了为什么用这个算法，为什么能出现这样的效果。（po猪就属于知道些皮毛的反面例子…） 。<br>好的滤镜效果（就跟PhotoShop一样效果的滤镜效果…）是要花时间和精力一点一点调出来的。<br>虽然通过GPU实现了滤镜效果，但是如何优化GPU的处理速度，如何减少减少GPU的消耗？如何去实现一个滤镜而不需要去“拼硬件”。<br>提高自身临场解决问题的能力，程序猿开始往工程狮的蜕变。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/KepenJ/CustomFilterDemo" target="_blank" rel="external">Demo源码</a></p>
<p><a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage相关源码及介绍介绍</a></p>
<p><a href="https://zh.wikipedia.org/wiki/OpenGL" target="_blank" rel="external">OpenGL相关wiki</a></p>
<p><a href="http://objccn.io/issue-21-6/" target="_blank" rel="external">Objc中国里面关于CoreImage的介绍</a></p>
<p><a href="http://bbs.lanou3g.com/forum.php?mod=viewthread&amp;tid=5016" target="_blank" rel="external">蓝鸥论坛里面针对Shader入门的一些实用讲解</a>（不是打广告，真的挺有用的-. -||）</p>
<p><a href="http://iphonedevsdk.com/forum/iphone-sdk-tutorials/14934-opengl-es-on-the-iphone.html" target="_blank" rel="external">老外OpenGLES讲解的干货</a></p>
<p><a href="https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/" target="_blank" rel="external">老外牛人破解出来的PhotoShop相关图形算法</a>(可能需要翻墙)</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2015/07/08/关于自定义一个滤镜效果/" data-id="cis8ow5rk00164nu5p0ifwr2p" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2015/07/28/iOS补漏和拾遗，从BAT的面试题出发（一）/" class="pre">iOS补漏和拾遗，从BAT的面试题出发（一）</a><a href="/2015/06/17/EffectiveOC学习整理-一/" class="next">EffectiveOC学习整理(一)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂感/">杂感</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/20/Github-代码阅读杂感——AFNetworking/">Github 代码阅读杂感——AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/05/C-学习笔记（六）：模板、字符串和异常/">C++学习笔记（六）：模板、字符串和异常</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/03/C-学习笔记（五）：运算符重载/">C++学习笔记（五）：运算符重载</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/01/C-学习笔记（四）：多态性与虚函数/">C++学习笔记（四）：多态性与虚函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/28/C-学习笔记（三）：继承和派生/">C++学习笔记（三）：继承和派生</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/22/Supporting-IPv6/">Supporting IPv6</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/21/C-学习笔记（二）：类和对象/">C++学习笔记（二）：类和对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/C-学习笔记（一）：C-基本和新增特性/">C++学习笔记（一）：C++基本和新增特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/21/iAP-的一波玩弄/">iAP 的一波玩弄</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/20/A-new-beginning/">A new beginning.</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/KepenJ" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Log'K'.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>